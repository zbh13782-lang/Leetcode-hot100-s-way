记录一些套路，模板之类的

## **1.单调栈**
背景：给定一个数组，求数组中某下标 *i* 的值 *nums[i]* 的下一个更大的值的下标 *j* ，或是求下一个更小的值

### 例题1：739.每日温度
给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
**示例 1:**

**输入:** temperatures = [73,74,75,71,69,72,76,73]
**输出:** [1,1,4,2,1,1,0,0]

**示例 2:**

**输入:** temperatures = [30,40,50,60]
**输出:** [1,1,1,0]

#### 固定模板：
```
//Golang

func mystack(nums []int) (ans []int) {
    n := len(nums)
    var Top func(num []int) (top int)
    Top = func(num []int) (top int) {
        return num[len(num)-1]

    }

    stack := []int{}
    ans = make([]int, n)
    for i := range ans {
		ans[i] = -1           //这里用-1表示不存在
    }

    for i, v := range nums {
        for len(stack) > 0 && v > nums[Top(stack)] {
            ans[Top(stack)] = i
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, i)
    }
    return ans
}
```

对于本题，我们要解决的是两个下标的差值
那么只要改一下ans就可以了：
1.把ans初始化为全0
2.更改ans的记录式 *ans[Top(stack)] = i - Top(stack)*

如果是要找下一个更小那么就改成v < nums[Top(stack)]

另外，还可以用这个模板逆向地找上一个更大 or 更小
只要修改为
```
for i := n-1 ;i>=0;i-- {
        for len(stack) > 0 && nums[i] > nums[Top(stack)] {
            ans[Top(stack)] = i
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, i)
    }
```

### 例题2：接雨水（2D）

这个问题应该不陌生
![[Pasted image 20260202165402.png]]

思路：找每个元素上一个最大和下一个最大，那么还是用单调栈来做

